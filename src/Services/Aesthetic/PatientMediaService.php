<?php

/**
 * Patient Media Service
 *
 * @package   OpenEMR
 * @link      http://www.open-emr.org
 * @author    OpenAI Assistant
 * @copyright Copyright (c) 2024 OpenAI
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 */

namespace OpenEMR\Services\Aesthetic;

use Document;
use Exception;
use OpenEMR\Common\Database\QueryUtils;
use OpenEMR\Services\DocumentService;
use OpenEMR\Validators\ProcessingResult;
use Ramsey\Uuid\Uuid;

require_once(__DIR__ . '/../../../library/ImageUtilities/Watermark.php');

require_once(__DIR__ . '/../../../library/classes/Document.class.php');

/**
 * Service responsible for handling the lifecycle of patient media assets used in aesthetic care flows.
 */
class PatientMediaService
{
    public const MEDIA_CATEGORY_PATH = '/Aesthetic_Media/Media_Gallery';
    private const ALBUM_TABLE = 'patient_media_album';
    private const ASSET_TABLE = 'patient_media_asset';
    private const TIMELINE_TABLE = 'patient_media_timeline';

    private DocumentService $documentService;

    public function __construct(?DocumentService $documentService = null)
    {
        $this->documentService = $documentService ?? new DocumentService();
    }

    /**
     * Creates a new album for the provided patient identifier.
     */
    public function createAlbum(int $patientId, array $payload): ProcessingResult
    {
        $result = new ProcessingResult();
        $title = trim($payload['title'] ?? '');
        if ($title === '') {
            $result->setValidationMessages(['title' => xlt('An album title is required.')]);
            return $result;
        }

        $description = trim($payload['description'] ?? '');
        $uuid = Uuid::uuid4()->toString();
        try {
            $insertId = QueryUtils::sqlInsert(
                'INSERT INTO `patient_media_album` (`uuid`, `patient_id`, `title`, `description`) VALUES (?, ?, ?, ?)',
                [$uuid, $patientId, $title, $description !== '' ? $description : null]
            );
            if ($insertId) {
                $result->addData([
                    'id' => $insertId,
                    'uuid' => $uuid,
                    'patient_id' => $patientId,
                    'title' => $title,
                    'description' => $description,
                ]);
            }
        } catch (Exception $e) {
            $result->addInternalError($e->getMessage());
        }

        return $result;
    }

    /**
     * Returns the non-deleted albums for a patient.
     */
    public function listAlbums(int $patientId): array
    {
        $sql = 'SELECT alb.`id`, alb.`uuid`, alb.`title`, alb.`description`, alb.`cover_asset_id`, '
            . 'alb.`created_at`, alb.`updated_at`, cover.`document_id` AS cover_document_id'
            . ' FROM `' . self::ALBUM_TABLE . '` alb'
            . ' LEFT JOIN `' . self::ASSET_TABLE . '` cover ON cover.`id` = alb.`cover_asset_id`'
            . ' WHERE `patient_id` = ? AND `deleted` = 0'
            . ' ORDER BY alb.`created_at` DESC';
        return QueryUtils::fetchRecords($sql, [$patientId]);
    }

    /**
     * Adds media assets to an album. Each element of $files should match the structure generated by PHP for a
     * multi-file upload (name, tmp_name, type, size, error).
     *
     * @param array $files array<int, array<string, mixed>>
     * @param array $metadataPerFile optional metadata keyed by index.
     */
    public function addAssets(
        int $patientId,
        int $albumId,
        array $files,
        array $metadataPerFile = [],
        array $options = []
    ): ProcessingResult {
        $result = new ProcessingResult();
        $album = $this->getAlbum($albumId, $patientId);
        if (empty($album)) {
            $result->setValidationMessages(['album' => xlt('Album not found for patient.')]);
            return $result;
        }

        $categoryId = $this->documentService->isValidPath(self::MEDIA_CATEGORY_PATH)
            ? $this->documentService->getLastIdOfPath(self::MEDIA_CATEGORY_PATH)
            : null;
        if ($categoryId === null) {
            $result->addInternalError(xlt('The document category for patient media is not available.'));
            return $result;
        }

        foreach ($files as $index => $fileData) {
            if (!is_array($fileData) || ($fileData['error'] ?? UPLOAD_ERR_OK) !== UPLOAD_ERR_OK) {
                $result->addInternalError(xlt('Upload error detected for one of the files.'));
                continue;
            }

            $metadata = $metadataPerFile[$index] ?? [];
            $consent = $metadata['consent_status'] ?? ($options['consent_status'] ?? 'pending');
            $capturedAt = $metadata['captured_at'] ?? null;
            $timelineNotes = $metadata['notes'] ?? null;
            $watermarkNotes = null;
            $watermarkApplied = 0;
            $preparedFile = $fileData['tmp_name'];

            if (!empty($options['watermark'])) {
                $watermarkTarget = $this->createWatermarkedCopy($fileData['tmp_name'], $options['watermark']);
                if ($watermarkTarget) {
                    $preparedFile = $watermarkTarget;
                    $watermarkNotes = is_array($options['watermark']) ? json_encode($options['watermark']) : (string)$options['watermark'];
                    $watermarkApplied = 1;
                }
            }

            try {
                $documentId = $this->storeDocument(
                    $patientId,
                    $categoryId,
                    $fileData['name'] ?? ('media-' . ($index + 1)),
                    $preparedFile
                );
                if (!$documentId) {
                    $result->addInternalError(xlt('Unable to persist one of the uploaded documents.'));
                    continue;
                }

                $assetUuid = Uuid::uuid4()->toString();
                $metaPayload = $metadata['metadata'] ?? ($metadata['extra'] ?? []);
                if (!empty($metadata) && empty($metaPayload)) {
                    $metaPayload = $metadata;
                }
                $metaJson = !empty($metaPayload) ? json_encode($metaPayload) : null;
                $capturedDate = $capturedAt ? date('Y-m-d H:i:s', strtotime((string)$capturedAt)) : null;

                $assetId = QueryUtils::sqlInsert(
                    'INSERT INTO `' . self::ASSET_TABLE . '`'
                    . ' (`uuid`, `album_id`, `patient_id`, `document_id`, `captured_at`, `metadata`, `consent_status`, `watermark_notes`, `watermark_applied`)' .
                    ' VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
                    [
                        $assetUuid,
                        $albumId,
                        $patientId,
                        $documentId,
                        $capturedDate,
                        $metaJson,
                        $consent,
                        $watermarkNotes,
                        $watermarkApplied,
                    ]
                );

                if ($assetId) {
                    $timelineUuid = Uuid::uuid4()->toString();
                    $eventDate = $capturedDate ?? date('Y-m-d H:i:s');
                    QueryUtils::sqlInsert(
                        'INSERT INTO `' . self::TIMELINE_TABLE . '`'
                        . ' (`uuid`, `patient_id`, `asset_id`, `event_type`, `event_date`, `notes`)' .
                        ' VALUES (?, ?, ?, ?, ?, ?)',
                        [
                            $timelineUuid,
                            $patientId,
                            $assetId,
                            $metadata['event_type'] ?? 'capture',
                            $eventDate,
                            $timelineNotes,
                        ]
                    );

                    $result->addData([
                        'asset_id' => $assetId,
                        'asset_uuid' => $assetUuid,
                        'document_id' => $documentId,
                        'timeline_uuid' => $timelineUuid,
                    ]);

                    if (empty($album['cover_asset_id'])) {
                        QueryUtils::sqlStatementThrowException(
                            'UPDATE `' . self::ALBUM_TABLE . '` SET `cover_asset_id` = ? WHERE `id` = ?',
                            [$assetId, $albumId]
                        );
                        $album['cover_asset_id'] = $assetId;
                    }
                }
            } catch (Exception $e) {
                $result->addInternalError($e->getMessage());
            } finally {
                if (isset($watermarkTarget) && $watermarkTarget !== $fileData['tmp_name'] && file_exists($watermarkTarget)) {
                    @unlink($watermarkTarget);
                }
            }
        }

        return $result;
    }

    /**
     * Retrieves timeline entries for the patient ordered from newest to oldest.
     */
    public function getTimeline(int $patientId): array
    {
        $sql = 'SELECT tl.`id`, tl.`uuid`, tl.`asset_id`, tl.`event_type`, tl.`event_date`, tl.`notes`, '
            . 'asset.`uuid` AS asset_uuid, asset.`album_id`, asset.`document_id`, asset.`captured_at`'
            . ' FROM `' . self::TIMELINE_TABLE . '` tl'
            . ' INNER JOIN `' . self::ASSET_TABLE . '` asset ON asset.`id` = tl.`asset_id`'
            . ' WHERE tl.`patient_id` = ?'
            . ' ORDER BY tl.`event_date` DESC, tl.`id` DESC';
        return QueryUtils::fetchRecords($sql, [$patientId]);
    }

    private function getAlbum(int $albumId, int $patientId): ?array
    {
        $sql = 'SELECT * FROM `' . self::ALBUM_TABLE . '` WHERE `id` = ? AND `patient_id` = ? AND `deleted` = 0';
        $album = QueryUtils::querySingleRow($sql, [$albumId, $patientId]);
        return $album ?: null;
    }

    private function storeDocument(int $patientId, int $categoryId, string $name, string $filePath): ?int
    {
        $doc = new Document();
        $fileContents = file_get_contents($filePath);
        if ($fileContents === false) {
            return null;
        }

        $mimeType = mime_content_type($filePath) ?: ($this->guessMimeTypeFromName($name));
        $createResult = $doc->createDocument($patientId, $categoryId, $name, $mimeType, $fileContents, '', 1, 0, $filePath);
        if (!empty($createResult)) {
            return null;
        }

        return $doc->get_id();
    }

    private function guessMimeTypeFromName(string $name): string
    {
        $extension = strtolower(pathinfo($name, PATHINFO_EXTENSION));
        return match ($extension) {
            'jpg', 'jpeg' => 'image/jpeg',
            'png' => 'image/png',
            'gif' => 'image/gif',
            'heic' => 'image/heic',
            default => 'application/octet-stream',
        };
    }

    private function createWatermarkedCopy(string $source, $watermarkOptions): ?string
    {
        $target = tempnam(sys_get_temp_dir(), 'pmw');
        if ($target === false) {
            return null;
        }

        if (!copy($source, $target)) {
            @unlink($target);
            return null;
        }

        $text = 'OpenEMR';
        if (is_string($watermarkOptions)) {
            $text = $watermarkOptions;
        } elseif (is_array($watermarkOptions) && isset($watermarkOptions['text'])) {
            $text = (string)$watermarkOptions['text'];
        }

        \OpenEMR\ImageUtilities\Watermark::applyTextWatermark($target, $target, $text);
        return $target;
    }
}
